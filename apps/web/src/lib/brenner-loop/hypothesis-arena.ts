/**
 * Hypothesis Arena - Competing Hypotheses Head-to-Head Comparison
 *
 * This module implements the core Brenner insight: science is about discriminating
 * between competing hypotheses, not just confirming one. Without competing
 * alternatives, researchers default to confirmation bias.
 *
 * Key concepts:
 * - Arena: A set of hypotheses competing to explain the same phenomenon
 * - Shared Tests: Tests that apply across multiple hypotheses
 * - Elimination: When a test definitively rules out a hypothesis
 * - Bold Predictions: Predictions that are specific and risky get higher weight
 *
 * > "The question is not whether your hypothesis is consistent with the data,
 * > but whether it's MORE consistent than the alternatives." — paraphrased from §89
 *
 * @see brenner_bot-an1n.6 (bead)
 * @see specs/operator_library_v0.1.md
 * @module brenner-loop/hypothesis-arena
 */

import type { HypothesisCard } from "./hypothesis";

// ============================================================================
// Internal Helper - Browser-safe UUID generation
// ============================================================================

function generateUUID(): string {
  // Use crypto.randomUUID() if available (modern browsers and Node.js 16+)
  if (typeof crypto !== "undefined" && typeof crypto.randomUUID === "function") {
    return crypto.randomUUID();
  }
  // Fallback for older environments
  const timestamp = Date.now().toString(36).toUpperCase();
  const random = Math.random().toString(36).substring(2, 6).toUpperCase();
  return `${timestamp}-${random}`;
}

// ============================================================================
// Core Types
// ============================================================================

/**
 * How a test result relates to a hypothesis.
 */
export type TestResultType = "supports" | "challenges" | "neutral" | "eliminates";

/**
 * Boldness level for a prediction - bolder = more informative.
 *
 * - vague: "Things will improve" (low information)
 * - specific: "Score will increase by 5-10%" (moderate)
 * - precise: "Score will be exactly 7.3" (high information)
 * - surprising: "Contrary to conventional wisdom, X will occur" (very high)
 */
export type PredictionBoldness = "vague" | "specific" | "precise" | "surprising";

/**
 * Status of a hypothesis in the arena.
 */
export type ArenaHypothesisStatus = "active" | "eliminated" | "suspended" | "champion";

/**
 * Source of a hypothesis - how it entered the arena.
 */
export type HypothesisSource =
  | "primary"         // Original user hypothesis
  | "object_transpose" // Generated by Object Transpose operator
  | "level_split"      // Generated by Level Split operator
  | "agent_suggested"  // Suggested by an AI agent
  | "user_added";      // Manually added by user

/**
 * A hypothesis entry in the arena with competition metadata.
 */
export interface ArenaHypothesis {
  /** Reference to the full HypothesisCard */
  hypothesisId: string;

  /** Direct reference to hypothesis (denormalized for convenience) */
  hypothesis: HypothesisCard;

  /** Source of this hypothesis */
  source: HypothesisSource;

  /** Current status in the arena */
  status: ArenaHypothesisStatus;

  /** When this hypothesis entered the arena */
  enteredAt: Date;

  /** Cumulative score from tests (can be negative) */
  score: number;

  /** Number of tests this hypothesis has faced */
  testsApplied: number;

  /** Number of tests that supported this hypothesis */
  testsSupporting: number;

  /** Number of tests that challenged this hypothesis */
  testsChallenging: number;

  /** If eliminated, the test that eliminated it */
  eliminatedBy?: string;

  /** If eliminated, when */
  eliminatedAt?: Date;

  /** If eliminated, the reason/evidence */
  eliminationReason?: string;

  /** User notes about this hypothesis in the competition */
  notes?: string;
}

/**
 * A prediction with assessed boldness for scoring.
 */
export interface ScoredPrediction {
  /** The prediction text */
  prediction: string;

  /** Which hypothesis made this prediction */
  hypothesisId: string;

  /** Boldness assessment */
  boldness: PredictionBoldness;

  /** Numeric boldness multiplier (calculated from boldness) */
  boldnessMultiplier: number;

  /** Was this prediction confirmed? */
  confirmed?: boolean;

  /** Evidence reference if confirmed/disconfirmed */
  evidenceId?: string;
}

/**
 * Result of applying a test to a hypothesis.
 */
export interface HypothesisTestResult {
  /** Unique identifier */
  id: string;

  /** Which hypothesis this result applies to */
  hypothesisId: string;

  /** Which test was applied */
  testId: string;

  /** The result type */
  result: TestResultType;

  /** Score delta from this test (positive = support, negative = challenge) */
  scoreDelta: number;

  /** Confidence in this result (0-1) */
  confidence: number;

  /** Boldness of the tested prediction (affects score multiplier) */
  predictionBoldness: PredictionBoldness;

  /** When this result was recorded */
  recordedAt: Date;

  /** Who recorded this result */
  recordedBy?: string;

  /** Notes about this specific result */
  notes?: string;
}

/**
 * A test applied across multiple hypotheses.
 */
export interface ArenaTest {
  /** Unique identifier */
  id: string;

  /** Test name/description */
  name: string;

  /** Which hypotheses this test was designed to discriminate between */
  targetHypotheses: string[];

  /** Expected discriminative power (0-3) */
  discriminativePower: number;

  /** Results for each hypothesis */
  results: HypothesisTestResult[];

  /** When the test was applied */
  appliedAt: Date;

  /** Who applied the test */
  appliedBy?: string;

  /** Test procedure/methodology */
  procedure?: string;

  /** Raw evidence reference */
  evidenceRef?: string;
}

/**
 * The main arena - competing hypotheses for a research question.
 */
export interface HypothesisArena {
  /** Unique arena identifier */
  id: string;

  /** The research question all hypotheses are trying to answer */
  question: string;

  /** The domain/field of research */
  domain?: string;

  /** When this arena was created */
  createdAt: Date;

  /** When last updated */
  updatedAt: Date;

  /** Who created the arena */
  createdBy?: string;

  /** Session ID if part of a session */
  sessionId?: string;

  /** Competing hypotheses */
  competitors: ArenaHypothesis[];

  /** Tests applied in this arena */
  tests: ArenaTest[];

  /** Overall arena status */
  status: "open" | "resolved" | "suspended";

  /** If resolved, which hypothesis won */
  championId?: string;

  /** If resolved, when */
  resolvedAt?: Date;

  /** Resolution notes */
  resolutionNotes?: string;

  /** Arena-level notes */
  notes?: string;

  /** Tags for categorization */
  tags?: string[];
}

/**
 * Comparison matrix row - one hypothesis's performance across tests.
 */
export interface ComparisonMatrixRow {
  /** Hypothesis ID */
  hypothesisId: string;

  /** Hypothesis statement (for display) */
  statement: string;

  /** Current status */
  status: ArenaHypothesisStatus;

  /** Current score */
  score: number;

  /** Results per test (testId -> result) */
  testResults: Record<string, TestResultType | "pending">;

  /** Current confidence level */
  confidence: number;
}

/**
 * Full comparison matrix for display.
 */
export interface ComparisonMatrix {
  /** Arena ID */
  arenaId: string;

  /** Research question */
  question: string;

  /** Column headers (test IDs and names) */
  tests: { id: string; name: string; appliedAt: Date }[];

  /** Row data for each hypothesis */
  rows: ComparisonMatrixRow[];

  /** Summary statistics */
  stats: {
    totalTests: number;
    activeHypotheses: number;
    eliminatedHypotheses: number;
    averageScore: number;
  };
}

// ============================================================================
// Constants
// ============================================================================

/**
 * Boldness multipliers for scoring predictions.
 * Bolder predictions get higher multipliers when confirmed/disconfirmed.
 */
export const BOLDNESS_MULTIPLIERS: Record<PredictionBoldness, number> = {
  vague: 0.5,
  specific: 1.0,
  precise: 2.0,
  surprising: 3.0,
};

/**
 * Score deltas for different test results.
 */
export const BASE_SCORE_DELTAS: Record<TestResultType, number> = {
  supports: 10,
  neutral: 0,
  challenges: -10,
  eliminates: -100, // Harsh penalty for elimination
};

/**
 * Labels for hypothesis sources.
 */
export const SOURCE_LABELS: Record<HypothesisSource, string> = {
  primary: "Original",
  object_transpose: "From Object Transpose (⟳)",
  level_split: "From Level Split (Σ)",
  agent_suggested: "Agent Suggested",
  user_added: "User Added",
};

/**
 * Status labels and colors.
 */
export const STATUS_CONFIG: Record<ArenaHypothesisStatus, { label: string; color: string }> = {
  active: { label: "Active", color: "green" },
  eliminated: { label: "Eliminated", color: "red" },
  suspended: { label: "Suspended", color: "amber" },
  champion: { label: "Champion", color: "primary" },
};

// ============================================================================
// Factory Functions
// ============================================================================

/**
 * Generate a new arena ID.
 */
export function generateArenaId(prefix: string = "ARENA"): string {
  return `${prefix}-${generateUUID()}`;
}

/**
 * Generate a new test result ID.
 */
export function generateTestResultId(): string {
  return `TR-${generateUUID()}`;
}

/**
 * Generate a new arena test ID.
 */
export function generateArenaTestId(): string {
  return `AT-${generateUUID()}`;
}

/**
 * Create a new hypothesis arena.
 */
export function createArena(input: {
  question: string;
  domain?: string;
  createdBy?: string;
  sessionId?: string;
  primaryHypothesis: HypothesisCard;
}): HypothesisArena {
  const now = new Date();
  const id = generateArenaId();

  const primaryCompetitor: ArenaHypothesis = {
    hypothesisId: input.primaryHypothesis.id,
    hypothesis: input.primaryHypothesis,
    source: "primary",
    status: "active",
    enteredAt: now,
    score: 0,
    testsApplied: 0,
    testsSupporting: 0,
    testsChallenging: 0,
  };

  return {
    id,
    question: input.question,
    domain: input.domain,
    createdAt: now,
    updatedAt: now,
    createdBy: input.createdBy,
    sessionId: input.sessionId,
    competitors: [primaryCompetitor],
    tests: [],
    status: "open",
  };
}

/**
 * Create an arena hypothesis entry from a HypothesisCard.
 */
export function createArenaHypothesis(
  hypothesis: HypothesisCard,
  source: HypothesisSource
): ArenaHypothesis {
  return {
    hypothesisId: hypothesis.id,
    hypothesis,
    source,
    status: "active",
    enteredAt: new Date(),
    score: 0,
    testsApplied: 0,
    testsSupporting: 0,
    testsChallenging: 0,
  };
}

// ============================================================================
// Arena Operations
// ============================================================================

/**
 * Add a competing hypothesis to an arena.
 */
export function addCompetitor(
  arena: HypothesisArena,
  hypothesis: HypothesisCard,
  source: HypothesisSource
): HypothesisArena {
  // Check for duplicates
  if (arena.competitors.some((c) => c.hypothesisId === hypothesis.id)) {
    throw new Error(`Hypothesis ${hypothesis.id} is already in this arena`);
  }

  const competitor = createArenaHypothesis(hypothesis, source);

  return {
    ...arena,
    competitors: [...arena.competitors, competitor],
    updatedAt: new Date(),
  };
}

/**
 * Calculate the score delta for a test result.
 */
export function calculateScoreDelta(
  result: TestResultType,
  boldness: PredictionBoldness,
  confidence: number = 1.0
): number {
  const baseScore = BASE_SCORE_DELTAS[result];
  const multiplier = BOLDNESS_MULTIPLIERS[boldness];
  return Math.round(baseScore * multiplier * confidence);
}

/**
 * Record a test result for a specific hypothesis.
 */
export function recordTestResult(
  arena: HypothesisArena,
  testId: string,
  hypothesisId: string,
  result: TestResultType,
  options: {
    confidence?: number;
    boldness?: PredictionBoldness;
    recordedBy?: string;
    notes?: string;
  } = {}
): HypothesisArena {
  const { confidence = 1.0, boldness = "specific", recordedBy, notes } = options;

  // Find the test
  const testIndex = arena.tests.findIndex((t) => t.id === testId);
  if (testIndex === -1) {
    throw new Error(`Test ${testId} not found in arena`);
  }

  // Find the competitor
  const competitorIndex = arena.competitors.findIndex((c) => c.hypothesisId === hypothesisId);
  if (competitorIndex === -1) {
    throw new Error(`Hypothesis ${hypothesisId} not found in arena`);
  }

  const scoreDelta = calculateScoreDelta(result, boldness, confidence);

  const testResult: HypothesisTestResult = {
    id: generateTestResultId(),
    hypothesisId,
    testId,
    result,
    scoreDelta,
    confidence,
    predictionBoldness: boldness,
    recordedAt: new Date(),
    recordedBy,
    notes,
  };

  // Update the test
  const updatedTest = {
    ...arena.tests[testIndex],
    results: [...arena.tests[testIndex].results, testResult],
  };

  // Update the competitor
  const competitor = arena.competitors[competitorIndex];
  const updatedCompetitor: ArenaHypothesis = {
    ...competitor,
    score: competitor.score + scoreDelta,
    testsApplied: competitor.testsApplied + 1,
    testsSupporting:
      result === "supports" ? competitor.testsSupporting + 1 : competitor.testsSupporting,
    testsChallenging:
      result === "challenges" || result === "eliminates"
        ? competitor.testsChallenging + 1
        : competitor.testsChallenging,
    // Handle elimination
    ...(result === "eliminates"
      ? {
          status: "eliminated" as ArenaHypothesisStatus,
          eliminatedBy: testId,
          eliminatedAt: new Date(),
          eliminationReason: notes,
        }
      : {}),
  };

  const updatedTests = [...arena.tests];
  updatedTests[testIndex] = updatedTest;

  const updatedCompetitors = [...arena.competitors];
  updatedCompetitors[competitorIndex] = updatedCompetitor;

  return {
    ...arena,
    tests: updatedTests,
    competitors: updatedCompetitors,
    updatedAt: new Date(),
  };
}

/**
 * Create a new test in the arena.
 */
export function createArenaTest(
  arena: HypothesisArena,
  input: {
    name: string;
    targetHypotheses: string[];
    discriminativePower?: number;
    procedure?: string;
    appliedBy?: string;
  }
): { arena: HypothesisArena; test: ArenaTest } {
  const test: ArenaTest = {
    id: generateArenaTestId(),
    name: input.name,
    targetHypotheses: input.targetHypotheses,
    discriminativePower: input.discriminativePower ?? 1,
    results: [],
    appliedAt: new Date(),
    appliedBy: input.appliedBy,
    procedure: input.procedure,
  };

  const updatedArena = {
    ...arena,
    tests: [...arena.tests, test],
    updatedAt: new Date(),
  };

  return { arena: updatedArena, test };
}

/**
 * Eliminate a hypothesis manually (e.g., based on external evidence).
 */
export function eliminateHypothesis(
  arena: HypothesisArena,
  hypothesisId: string,
  reason: string,
  eliminatedBy?: string
): HypothesisArena {
  const competitorIndex = arena.competitors.findIndex((c) => c.hypothesisId === hypothesisId);
  if (competitorIndex === -1) {
    throw new Error(`Hypothesis ${hypothesisId} not found in arena`);
  }

  const competitor = arena.competitors[competitorIndex];
  const updatedCompetitor: ArenaHypothesis = {
    ...competitor,
    status: "eliminated",
    eliminatedAt: new Date(),
    eliminationReason: reason,
    eliminatedBy,
    score: competitor.score + BASE_SCORE_DELTAS.eliminates,
  };

  const updatedCompetitors = [...arena.competitors];
  updatedCompetitors[competitorIndex] = updatedCompetitor;

  return {
    ...arena,
    competitors: updatedCompetitors,
    updatedAt: new Date(),
  };
}

/**
 * Declare a champion (resolve the arena).
 */
export function resolveArena(
  arena: HypothesisArena,
  championId: string,
  notes?: string
): HypothesisArena {
  const championIndex = arena.competitors.findIndex((c) => c.hypothesisId === championId);
  if (championIndex === -1) {
    throw new Error(`Hypothesis ${championId} not found in arena`);
  }

  const champion = arena.competitors[championIndex];
  if (champion.status === "eliminated") {
    throw new Error("Cannot declare an eliminated hypothesis as champion");
  }

  const updatedCompetitors = arena.competitors.map((c) =>
    c.hypothesisId === championId
      ? { ...c, status: "champion" as ArenaHypothesisStatus }
      : c
  );

  return {
    ...arena,
    competitors: updatedCompetitors,
    status: "resolved",
    championId,
    resolvedAt: new Date(),
    resolutionNotes: notes,
    updatedAt: new Date(),
  };
}

// ============================================================================
// Query Functions
// ============================================================================

/**
 * Get active (non-eliminated) hypotheses.
 */
export function getActiveHypotheses(arena: HypothesisArena): ArenaHypothesis[] {
  return arena.competitors.filter((c) => c.status === "active" || c.status === "champion");
}

/**
 * Get eliminated hypotheses (the "graveyard").
 */
export function getEliminatedHypotheses(arena: HypothesisArena): ArenaHypothesis[] {
  return arena.competitors.filter((c) => c.status === "eliminated");
}

/**
 * Get the current leader (highest scoring active hypothesis).
 */
export function getLeader(arena: HypothesisArena): ArenaHypothesis | undefined {
  const active = getActiveHypotheses(arena);
  if (active.length === 0) return undefined;
  return active.reduce((leader, current) =>
    current.score > leader.score ? current : leader
  );
}

/**
 * Get hypotheses ranked by score.
 */
export function getRankedHypotheses(arena: HypothesisArena): ArenaHypothesis[] {
  return [...arena.competitors].sort((a, b) => b.score - a.score);
}

/**
 * Calculate the discriminative power of the arena.
 * Higher = tests are doing a good job differentiating.
 */
export function calculateDiscriminativePower(arena: HypothesisArena): number {
  if (arena.competitors.length < 2) return 0;

  const active = getActiveHypotheses(arena);
  if (active.length === 0) return 0;

  const scores = active.map((c) => c.score);
  const maxScore = Math.max(...scores);
  const minScore = Math.min(...scores);
  const range = maxScore - minScore;

  // Normalize by number of tests
  const testWeight = Math.min(arena.tests.length / 3, 1); // Max out at 3 tests

  return Math.min(range * testWeight / 100, 1);
}

// ============================================================================
// Comparison Matrix
// ============================================================================

/**
 * Build a comparison matrix for display.
 */
export function buildComparisonMatrix(arena: HypothesisArena): ComparisonMatrix {
  const rows: ComparisonMatrixRow[] = arena.competitors.map((competitor) => {
    // Build test results map
    const testResults: Record<string, TestResultType | "pending"> = {};

    for (const test of arena.tests) {
      const result = test.results.find((r) => r.hypothesisId === competitor.hypothesisId);
      if (result) {
        testResults[test.id] = result.result;
      } else if (test.targetHypotheses.includes(competitor.hypothesisId)) {
        testResults[test.id] = "pending";
      }
    }

    return {
      hypothesisId: competitor.hypothesisId,
      statement: competitor.hypothesis.statement,
      status: competitor.status,
      score: competitor.score,
      testResults,
      confidence: competitor.hypothesis.confidence,
    };
  });

  // Sort by score (descending)
  rows.sort((a, b) => b.score - a.score);

  const active = getActiveHypotheses(arena);
  const eliminated = getEliminatedHypotheses(arena);

  return {
    arenaId: arena.id,
    question: arena.question,
    tests: arena.tests.map((t) => ({ id: t.id, name: t.name, appliedAt: t.appliedAt })),
    rows,
    stats: {
      totalTests: arena.tests.length,
      activeHypotheses: active.length,
      eliminatedHypotheses: eliminated.length,
      averageScore: active.length > 0
        ? Math.round(active.reduce((sum, h) => sum + h.score, 0) / active.length)
        : 0,
    },
  };
}

// ============================================================================
// Type Guards
// ============================================================================

/**
 * Type guard for HypothesisArena.
 */
export function isHypothesisArena(obj: unknown): obj is HypothesisArena {
  if (typeof obj !== "object" || obj === null) return false;
  const arena = obj as Record<string, unknown>;
  return (
    typeof arena.id === "string" &&
    typeof arena.question === "string" &&
    Array.isArray(arena.competitors) &&
    Array.isArray(arena.tests)
  );
}

/**
 * Type guard for ArenaHypothesis.
 */
export function isArenaHypothesis(obj: unknown): obj is ArenaHypothesis {
  if (typeof obj !== "object" || obj === null) return false;
  const h = obj as Record<string, unknown>;
  return (
    typeof h.hypothesisId === "string" &&
    typeof h.source === "string" &&
    typeof h.status === "string" &&
    typeof h.score === "number"
  );
}

// ============================================================================
// Boldness Assessment
// ============================================================================

/**
 * Assess the boldness of a prediction based on its text.
 * Uses heuristics - could be improved with AI.
 */
export function assessPredictionBoldness(prediction: string): PredictionBoldness {
  const text = prediction.toLowerCase();

  // Check for surprising/contrarian claims
  if (
    text.includes("contrary to") ||
    text.includes("despite") ||
    text.includes("unexpectedly") ||
    text.includes("counterintuitively") ||
    text.includes("against conventional")
  ) {
    return "surprising";
  }

  // Check for precise numeric claims
  if (/\b\d+\.?\d*%?\b/.test(text) || /\bexactly\b/i.test(text) || /\bprecisely\b/i.test(text)) {
    return "precise";
  }

  // Check for specific but not exact claims
  if (
    text.includes("between") ||
    text.includes("increase") ||
    text.includes("decrease") ||
    text.includes("more than") ||
    text.includes("less than") ||
    text.includes("within")
  ) {
    return "specific";
  }

  // Default to vague
  return "vague";
}

/**
 * Score a set of predictions for a hypothesis.
 */
export function scorePredictions(hypothesisId: string, predictions: string[]): ScoredPrediction[] {
  return predictions.map((prediction) => {
    const boldness = assessPredictionBoldness(prediction);
    return {
      prediction,
      hypothesisId,
      boldness,
      boldnessMultiplier: BOLDNESS_MULTIPLIERS[boldness],
    };
  });
}

/**
 * Get the average boldness score for a hypothesis's predictions.
 */
export function getAverageBoldness(hypothesis: HypothesisCard): number {
  const allPredictions = [
    ...hypothesis.predictionsIfTrue,
    ...hypothesis.predictionsIfFalse,
    ...hypothesis.impossibleIfTrue,
  ];

  if (allPredictions.length === 0) return 0;

  const scored = scorePredictions(hypothesis.id, allPredictions);
  const total = scored.reduce((sum, p) => sum + p.boldnessMultiplier, 0);
  return total / scored.length;
}
